\chapter{Implementation Part II: Dictionary Encoding}
\label{chap:part3}
In this chapter, we explain how more performance is acheived by introducing dictionary compression.

\section{Dictionary Encoding}
\label{sec:Dictionary Encoding}
We read in the background section that dictionary encoding is commonly used to store data in a database. Such encoding has several benefits, with the main being compression. Some operations also benefit from integer comparisons which are cheap compared to for instance string coparisons.

In a dictionary encoded column, the dictionary could be optimized for insert operations or for read optimizations. We chose the latter, where the dictionary is implemented as a simple list of elements.


We chose to implement the dictionary for read performance.


\section{Bitpacking}
\label{sec:Bitpacking}
In the background section, we see that dictionary encoding and bitpacking goes hand in hand. We implement a simple version to save more memory. 

The bitpacking dictionary works very much like the ordinary dictionary encoding. We chose to use a growth strategy where each value takes 1, 2, 4, 8, 16.. bits to avoid extracting values across word boundaries. Hence, the number of distinct values a column can contain is $2^{2^n}$.

The value buffer is implemented as an array of 64-bit values which we denote an \textit{cells}. A cell is added one at a time as the buffer fills up. If the dictionary fills up, a \fn{IncreaseDictionaryCapasity} function is called. This allocates a new value cell array of double size and moves all values from the old cells into the new one, except extra padding is added.


\section{Compressing pointers with DefaultStore}
\label{sec:Compressing pointers with DefaultStore}


\section{Chapter Conclusion}
\label{sec:Chapter Conclusion}
We have reduced memory footprint by xxx, but we have yet to see how to utilize these structures even more.

\subsection{Future Work}
\label{sub:Future Work}
