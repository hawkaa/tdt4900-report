\chapter{Implementation Part II: Enhancing Storage Format}
\label{chap:part2}
In this chapter, we explain how more performance is acheived by introducing native data types and dictionary compression.

\section{Replacing GValues with Native Data Types}
\label{sec:Replacing GValues with Native Data Types}
One of the challenges with the current implementation, was that for each \cn{GValue}, there was a 12 byte overhead, which is pretty significant. That seems pretty unecessary to store a boolean, which generally takes up only one byte. 

In Chapter \ref{chap:Background}, we saw that \delphi~has several simple data types, including \vn{Integer}, \vn{Boolean}, \vn{Double}, etc. We propose to not store \cn{GValue} instances within the columns, but rather such simple data types. However, since the column operations still uses \cn{GValue} in its access methods, the data has to be extracted from these instances on its way in, and new \cn{GValues} must be created on the way out. In this research, we refer to these simple data types an \textit{Native Data Types}.

The implementation was straight forward. We create another implementation of the \cn{FieldValueCollection} interface with sub-classes for each data type. 

\subsection{Native Value Helper}
\label{sub:Native Value Helper}
\begin{delphicode}{Passing double array pointers}{lst:double-array-pointers}
function NativeFieldValueCollection<TDataType>.GetValue
( index : integer )
: CGValue;
begin
  EnsureCapacity(index);
  if not nilFlags[index] then
    Result := valueHelper.CreateCGValue(values[index])
  else
    Result := nil;
end;
\end{delphicode}
As a part of the native value column implementation, we create a helper class we call \cn{NativeValueHelper}. This class is a generic class and is owned by the \cn{NativeFieldValueCollection} base class. This class has the current core functionality:
\begin{itemize}
    \item \fn{ExtractValue} - Inputs an \cn{GValue} and outputs the native value.
    \item \fn{CreateGValue} - Creates a \cn{GValue} from a native value.
    \item \fn{ValueEquals} - Compares two native values without creating \cn{GValues}.
\end{itemize}
The base class is inherited by one subclass per data type supported.

\section{Loading raw data values}
\label{sec:Loading raw data values}

\section{Chapter Conclusion}
\label{sec:Chapter Conclusion}

\subsection{Future Work}
\label{sub:Future Work}
We see a potential in loading XML values directly, however our implementation did nothing but decrease performance since the caching mechanisms was disabled. A more thorough implementation is outside of the scope of this research. Future work should investigate the effects of loading XML data directly into the columns and have the column store handle all caching using dictionary encoding. In theory, all caching should be handled by the column store using a loading state.
