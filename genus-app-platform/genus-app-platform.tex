\chapter{Genus App Platform}
\label{chap:gap}

This chapter contains a top-down analysis of \gap, containing platform architecture, how applications are developed using the platform, concepts, and source code. The last part of this chapter identifies challenges in Genus App Platform, which motivates the second and primary part of this thesis, which is the design and experiment research.

We obtained information for this chapter by reading technical briefs, attending platform courses, engaging discussions with \genus' employees, and source code analysis.


\clearpage
\section{Introduction}
\label{sec:Introduction}


\gap~is a platform for software development that aims to increase developer productivity and simplify change management through model-driven development \cite{Genus_AS2016-kt}. \gap~is a "no code" tool, which means end user applications are modeled without writing a single line of code. This approach enhances collaboration between business and IT, reduces life cycle costs, and lets the application developers focus on business logic instead of implementation details. 

\gap~uses generic software concepts on a higher level of abstraction than regular programming languages that are precise and non-ambigous \cite{noauthor_undated-qy}. These concepts, and how they are implemented in the underlying platform, have been refined and improved through years of trial and error on real customer use cases.

If we relate \gap~to the model layers defined in Section \ref{sub:Models and Model Levels}, we see that it spans over three layers: \gap~platform developers work in the \textit{method engineering (ME) layer}, while expert users using the modeling tool to create end user applications work on the \textit{information system development (ISD) layer}. End users are in the \textit{information system (IS) layer}.

\section{Components and Architecture}
\label{sec:Components and Architecture}
\afigure{img/gap-components.png}{Components in \gap. \textit{Genus App Services} connects end user and modeling clients with the underlying database infrastructure, and provides authentication and session management. (Adapted from \cite{Genus_AS2016-kt})}{fig:gap-components}{0.7}


\gap~consists of five major components, as seen in Figure \ref{fig:gap-components}. These include two backend components, \textit{database infrastructure} and \textit{Genus App Services}, and one component for application modeling, \textit{Genus Studio}. \textit{Genus Desktop} and \textit{Genus Apps} are end user clients for \textit{Windows} and mobile devices respectively.

\subsection{Database Infrastructure}
\label{sub:Database Infrastructure}
The database infrastructure stores the application data, as well as the application itself (application model). \gap~connects to a wide variety of data providers, often traditional relational databases such as \pn{Oracle Database}, \pn{Microsoft SQL Server}, and \pn{MySQL}. However, there exists several adapters, or object-relational mappers, for other data sources, including SOAP-based web services. More integrations are planned in the future, which includes adapters for NoSQL databases and RESTful web APIs. 

Applications developed in \gap~may build on already existing data sources or define a new, or partially new, data source to store application data. Since \gap~handles all data integrity with validations, triggers, duplicate handling, and foreign keys, such constraints do not need to be specified and defined in the database infrastructure.


\subsection{Genus App Services}
\label{sub:Genus App Services}
\pn{Genus App Services} is the main backend component in \gap. It facilitates communication between the clients and the database infrastructure, handles authentication, and manages sessions. \pn{Genus App Services} is made up of several nodes and node groups, where each node in a node group is configured to run one or more services that are required by the application. Requests to \pn{Genus App Services} are sent to the right node group based on application model and application dataset, and to the correct node based on which service is required. 

All nodes in \pn{Genus App Services} are stateless. This principle simplifies horizontal scaling since more nodes may be added if one particular service becomes a bottleneck. Nodes may still use caching mechanisms for performance reasons.

\subsection{Genus Studio}
\label{sub:Genus Studio}
\pn{Genus Studio} is the software modeling tool in \gap. In this tool, expert users use models close to the business problem and generic software concepts to create end user applications. In \mde~terminology, this tool belongs to the information system development layer. We study application development in \textit{Genus Studio} in Section \ref{sec:Application Development}.

\textit{Genus Studio} runs on the \textit{Windows} platform.

\subsection{Genus Desktop and Genus Apps}
\label{sub:Genus Desktop and Genus Apps}
\textit{Genus Desktop} and \textit{Genus Apps} are the end user clients for \textit{Windows} and mobile platforms respectively. End users access their applications and their respective data using these clients. Instances of these clients point to an application model and a corresponding dataset, and they communicate with \textit{Genus App Services} to receive sufficient model information and data to run the application. 

In \mdd~terminology, \textit{Genus Desktop} and \textit{Genus Apps} correspond to the \textit{Information System Layer}.

\section{Application Development}
\label{sec:Application Development}
\textit{Genus Studio} is the software modeling tool in \gap and is used by expert users to design and develop end user applications. Applications are defined by specifying three different layers: The \textit{data layer}, \textit{logic layer}, and \textit{user interface layer}. These layers are analogous to the information structure, microflow, and form models used by \mendix.

\subsection{Data Layer}
\label{sub:Data Layer}
\afigure{img/gap-data-layer.png}{The data layer in \gap. This layer defines object classes, object relationships, data integrety and calculation, and security. (Adapted from \cite{Genus_AS2016-kt})}{fig:gap-data-layer}{0.8}

One of the layers in \gap~application development is the \textit{data layer}, which is seen in Figure \ref{fig:gap-data-layer}. This layer contains object class definitions with properties, as well as hierarchies and connections to explain how object classes relate to each other. The data layer specifies how data is fetched and stored in the underlying database infrastructure, for instance by specifying database connection strings and table names. Schemas in the data layer represents how the object model is represented when exposed through an API, which are primarily used to create and consume SOAP based web services.

The data layer provides security functionality. This feature limits access to certain objects or certain properties. Other core functionality specified in the data layer include integrity and validity checks, formulas, triggers, and events.

The data layer with is modelled in a class diagram, which we will discuss in greater detail in Section \ref{sec:Concepts}.

\subsection{Logic Layer}
\label{sub:Logic Layer}
% Logic layer: Vi kaller byggeklossene for Effects (siden de har «side»-effekter) og prosessen med å sette dem sammen for Action Orchestration.

% skriv om denne etterpå
\afigure{img/gap-logic-layer.png}{The logic layer in \gap. Here, effects are specified through action orchestration. Effects contain programming-like constructs and is composed of a wide variety of actions. (Adapted from \cite{Genus_AS2016-kt})}{fig:gap-logic-layer}{1.0}

The \textit{logic layer} in \gap~lets the modeller extend the application with custom logic. The main components in this layer are \textit{effects}, which is analogous to the microflows in \mendix.  The logic layer is shown in \ref{fig:gap-logic-layer}.

Effects are created through \textit{Action Orchestration}, which lets the system developer specify logic through programming language-like constructs, such as loops, conditional statements, and exceptions. There is a large number of different actions that might be included in an orchestration, which include object creation, modification, and delete, file handling, and consuming web services. There are several ways to run an effect; for instance through clicks and interaction in the user interface, recurring events triggered by a timer, or triggers caused by changes in the data.

%For our research, the most important parts of the logic layer is the object fetching and manipulation, as well as the data aggregate generation. We study this later in the thesis.

\subsection{User Interface Layer}
\label{sub:User Interface Layer}
\afigure{img/gap-user-interface-layer.png}{The user interface layer in \gap. In this layer, forms and tables are specified, with a wide variety of available GUI elements. (Adapted from \cite{Genus_AS2016-kt})}{fig:gap-user-interface-layer}{1.0}
In the \textit{user interface layer}, the UI made available to the end users are specified. The main components in this layer are the form and table views. Form views allow the modeler to specify custom layouts and include a wide variety of different GUI elements. Supported elements, which is seen in Figure \ref{fig:gap-user-interface-layer}, include text boxes, buttons, calendars, maps, and more. A form is designed for either \textit{Genus Desktop} or \textit{Genus Apps}. 

The user interface layer fetches data from the data layer through a data source. The data sources defined for a form or table specifies which data that are available in the user interface. The GUI may interact with the logic layer through user interaction, such as button clicks. \todo{Horrible quality on this section}

\section{Concepts}
\label{sec:Concepts}
To better understand how the three application development layers relate to \gap~source code, we elaborate on some important concepts used in the platform.

\subsection{Object Classes}
\label{sub:Object Classes}
\afigure{img/gap-class-diagram.png}{Class diagram from \textit{Genus Studio} for the \tpch. Blue units represent object domain compositions which means they are mapped to the underlying database infrastructure. White units represent code domain compositions where values are "hard coded" and fetched from the application model itself.}{fig:gap-class-diagram}{1.0}
An object class in \gap~is a hybrid between a table definition in a relational database and a class in a programming language. An object class, sometimes referred to a composition, specifies several class properties (Section \ref{sub:Object Class Properties}), security settings, integrity constraints, formulas, and other display options. An object class can either be in the \textit{object domain} or the \textit{code domain}. Compositions belonging to the object domain must specify how it relates to the underlying database infrastructure, for instance by providing a database connection string and table name, or an XML schema if the data is fetched using a SOAP-based web service. Object classes in the code domain does not have this ability, since these values are "hard coded" into the application model, and not fetched from any data source.

Object classes are defined in the application data layer, and specified in a class diagram, which is depicted in Figure \ref{fig:gap-class-diagram}.


\subsection{Object Class Properties}
\label{sub:Object Class Properties}
An object class is composed of one or more properties. Such properties can be simple data types, like integers and strings, or a function type, which calculates their value based on other properties in the class. In addition to specifying the basic data type that holds the value, properties also define an interpretation of the data. There exists many such interpretations in \gap, including \textit{file}, \textit{password}, \textit{date format}, and \textit{color}. The data interpretation may also be another object class, which is used on foreign key fields. This creates relationships between object classes in the data layer.

An object class property has its own set of security and validation rules, and includes display options like formatting and screen tip.

\subsection{Data Source}
\label{sub:Data Source}

\todo{content good, language crap. rewrite entire section}

A \textit{data source} in \gap~is used by effects, tables, and forms to retrieve, create, modify, or delete data. A data source must specify which object class that belongs to the source, whether the data source can have one or multiple instances, and which data should be loaded into the data source. The data in a data source is stored by the clients in main memory. \todo{Crap paragraph}

Which data that should be loaded into a data source is commonly specified by using a filter. This filter is translated to SQL or other relevant query language and sent to the database infrastructure. Thus, \gap~utilizies efficient database servers, and no more data than needed traverses the network. However, there are no requirements that a data source must load any elements, empty data sources can for instance be used for temporary in-memory processing. \todo{Crap pargarph, rewrite, but important content}

\subsection{Analysis}
\label{sub:Analysis}
\afigure{img/tpc-h-q1-ui.png}{\gap~analysis component. REPLACE IMAGE}{fig:genus-discovery}{0.8}
The \textit{analysis} component, sometimes refered to as \textit{Genus Discovery}, is the \bd~functionality in \gap. \textit{Genus Discovery} is is very similar to \qlikview, which we studied in \ref{sec:Business Discovery}, but since object classes and relations are already specified in the data layer, no data import script is needed. Like \qlikview, the analysis component allows end users to follow their "information scent" and click their way through the data using an intuitive user interface. An example user interface is seen in Figure \ref{fig:genus-discovery}.

One particular dashboard is referred to as \textit{an analysis}. Each analysis links to a specific data extract, or \textit{data mart}, which we study in the next section.

\subsection{Data Mart}
\label{sub:Data Mart}
\afigure{img/gap-data-mart.png}{Data mart for Q1 in \tpch, which contains only the object classes and fields needed to answer that particular query. The mart conforms to a snowfalke schema.}{fig:gap-data-mart}{0.7}

A data mart defines a data extract that is used by the analysis component in \gap. A data mart is specified by a set of data sources, and for each data source, a list of published fields. All data sources in a mart might specify a filter, such that the analyses only access a particular subset of the data. 

The process and user interface to define a data mart is very similar to defining object classes in an object diagram, like seen in Figure \ref{fig:gap-data-mart}. However, there is one important distinction: A data mart must conform to a snowflake schema, which means there can only exist one path through the class diagram. For instance, in Figure \ref{fig:gap-class-diagram}, both the customer and supplier classes refer to the nation class. In a data mart, there would be two nation entities; one entity for customer nationality and one for supplier nationality.

\subsection{Tasks}
\label{sub:Tasks}
\afigure{img/gap-task.png}{A task definition in \gap. A task is composed of actions and effects. This way, a task may read from and to data sources, enumerate using for or while loops, consume services, import, export, and more.}{fig:gap-task}{1.0}
Tasks in \gap~are similar to a procedure or a function in a programming language, and is defined at the logic layer. Tasks are created through action orchestration where actions and effects are combined to create logic. Action orchestration is done using a user interface, which is depicted in Figure \ref{fig:gap-task}. Tasks use data sources to retrieve, create, modify, or delete data. Tasks might be triggered manually, by user interaction with the user interface, or by agents that run effects periodically. \todo{Still confused on task/effect/action}

\section{Source Code and Classes}
\label{sec:Source Code and Classes}
\afigure{img/gap-original-class-diagram.png}{A class diagram containing the most important classes to understand how data is stored and accessed in \gap.}{fig:gap-original-class-diagram}{0.8}
This section aims to give an overview over the classes in \gap~source code that are used to represent object classes, object instances, and data elements. A class diagram for the classes we discuss is presented in Figure \ref{fig:gap-original-class-diagram}.

The source code of \gap~core is written in \delphi, which we studied in Section \ref{sec:Delphi Programming Language}.

\subsection{GValue}
\label{sub:GValue}
The \cn{GValue} class, short for \textit{Genus Value} is a base class that can contain any value of any type that is supported in the platform. These types include integers, floating point numbers, strings, object handles, dates, and more. The \cn{GValue} class is a necessity in \gap~to omit the rigid type system in \delphi~such that all values can be handled the same way. The class contains comparison methods and utility functions for type conversions. The \cn{GValue} type is used in both information system and information system development layers.

For all value type supported in the system, there are get and set methods for that specific value type defined in the base class. These methods are not implemented in the \cn{GValue} class, but by subclasses defined for the various data types. For instance, there exists a \cn{IntegerValue} that extends \cn{GValue} which overrides the \cn{GetAsInteger} and \cn{SetAsInteger} methods. Each subclass also contains a member variable to store the actual data.

% memory handling
A \cn{GValue} is a class type and not a record type, hence is allocated by the memory manager and put on the heap. The \cn{GValue} has built-in reference counting to enable cloning.

\subsection{CompositionDescriptor and CompositionObject}
\label{sub:CompositionDescriptor}
The object class, or composition, which we discussed in Section \ref{sub:Object Classes}, is represented through the \cn{CompositionDescriptor} and \cn{CompositionObject} classes. Since \gap~source code is developed in one layer of abstraction above a regular programming language, we need two classes to support compositions, as we see in Figure \ref{fig:linguistic-metamodeling}. The relationship between the descriptor and the object is normally built into the language as classes and objects, but in a model-driven framework, there must be two explicit constructs.

The \cn{CompositionDescriptor} class describes a composition, and represents an object class. Conceptually, such descriptor is the same as a class in a programming language. As described Section \ref{sub:Object Classes}, a composition descriptor contains a list of data descriptors as well as ... \todo{Trenger hjelp her}. A composition descriptor contains data from the information system delevopment layer.

The \cn{CompositionObject} class represents object instances for object classes. Each object has a reference to its composition descriptor, and in addition, there are other variables that store object state, validation errors, formatting, and more. The properties and data belonging to a composition object instance is stored in a \cn{CompositionObjectValueCollection} class, which we study in Section \ref{sub:CompositionObjectValueCollection}.


\subsection{FieldDescriptor}
\label{sub:DataDescriptor}
The \cn{FieldDescriptor} class describes an attribute in a composition, which is the object class property we studied in Section \ref{sub:Object Class Properties}. It holds all revelant data about a property, mainly type and representation, but also constraints and formatting rules. Instances of the \cn{DataDescriptor} class exist in the information system development layer.

\subsection{CompositionObjectValueCollection}
\label{sub:CompositionObjectValueCollection}
The \cn{CompositionObjectValueCollection} class holds the data for composition objects, and is equivalent to the data stored in class properties in a regular programming language. Alternatively, this collection class can be thought of as a row in a DBMS. The class contains a list of \cn{GValue}s and a list of \cn{DataDescriptor}s. Values are accessed through querying the \cn{CompositionObjectValueCollection} with a \cn{DataDescriptor}, where the correct value is found using a linear search through the list.

\begin{table}
    \begin{tabularx}{\textwidth}{X | X | X}
        Class Name & Concept & Model-driven development layer \\
        \hline
        \hline
        \cn{GValue} & - & Method engineering layer \\
        \hline
        \cn{CompositionDescriptor} & Object Class & Information system development layer \\
        \hline
        \cn{CompositionObject} & Instance of Object Class & Information system layer \\
        \hline
        \cn{FieldDescriptor} & Object Class Property & Information system development layer \\
        \hline
        \cn{CompositionObject- ValueCollection} & Values of Object Class Property & Information system layer
    \end{tabularx}
    \caption{Classes and layers}
    \label{tab:concept-class-mapping}
\end{table}

An overview over classes, and how they relate to \gap~concepts and model-driven engineering layers is found in Table \ref{tab:concept-class-mapping}.

\section{Challenges in Genus App Platform}
\label{sec:Challenges in Genus App Platform}
There is a number of challenges in the current design of \gap. The main focus of the source code has been to have a readable code that is easy to maintain \todo{Stemmer dette?}. However, making code readable and mainainable have lead to an implementation that is not optimized for performance. In this section, we discuss some of the challenges in \gap, which are related to memory usage and memory access.

\subsection{Excessive amount of pointers}
\label{sub:Excessive amount of pointers}
\afigure{img/gap-original-instantiation.png}{Pointers in \gap. For every object, there is not only a list to the values, but also a list to the corresponding data descriptors.}{fig:gap-original-instantiation}{0.8}
One of the main challenges in \gap~is the large amount of pointers needed to store object data. As we saw in Section \ref{sub:CompositionObjectValueCollection}, each \cn{CompositionObjectValueCollection} not only stores \cn{GValue}s containing the data, but but also pointers to all data descriptors. Although this implementation is flexible because every value collection is self-contained and objects can have a variable number of fields lodaded, the overhead for storing all these pointers is substantial. This is especially true on a 64-bit architecture, where each pointer uses 8 bytes. The pointers are indicated as arrows in Figure \ref{fig:gap-original-instantiation}.

We study the pointer overhead by using a simple example. We assume an object class with 15 class properties. In the data source there are 1,000,000 million elements. Here, we see the amount of pointers needed:
\begin{itemize}
    \item \textbf{1 pointer}, for the data source.
    \item \textbf{2 pointers}, for the composition descriptor and the pointer to the list of data descriptors.
    \item \textbf{15 pointers}, for the composition data descriptors
    \item Then, for every object:
    \begin{itemize}
        \item \textbf{1 pointer}, for the composition object.
        \item \textbf{1 pointer}, for the value collection pointer.
        \item \textbf{15 pointers}, for all data descriptors in the value collection.
        \item \textbf{15 pointers}, for all values in the value collection.
    \end{itemize}
\end{itemize}
This results in 32,000,018 pointers, which is roughly 244mb on a 64-bit architecture. Keep in mind that this number only contains storage used for pointers, not the actual data itself. If all values are 32-bit integers, the raw data itself would only take up approximately 57mb, which in this example is only 20\% of the pointers.

\subsection{Ineficcient Data Access and Poor Memory Locality}
\label{sub:Ineficcient Data Access and Poor Memory Locality}
Sometimes in \gap, there are operations that perform calculations or evaluate predicates on a large number of values. These operations access many values in tight loops, and it is not uncommon they scan all values for a given data descriptor in a data source. For instance, an operation that sums up all numbers for an object property in a data source would for every iteration do the following:
\begin{itemize}
    \item The \cn{CompositionObjectValueCollection} is scanned linearly for the correct data descriptor.
    \item The corresponding \cn{GValue} is found, and the accessor method (i.e. \fn{GetAsInteger}) is looked up in the dispatch table.
    \item A new stack frame is put on the stack to run the \fn{GetAsInteger} method.
\end{itemize}

Although the compiler might be able to optimize some of the steps above, it is far from ideal. For instance, the accessor method for the value is virtual and cannot be inlined. As we saw in Section \ref{sec:Background Information on Modern CPUs and Compilers}, the difference between minimal and maximal CPU utilization can easily be one order of magnitude, where branches and new stack frames may severely hurt performance. Last, the linear search through data descriptors hurts performance.

Not only is the data access pattern complex, we may also assume poor memory locality. As \cn{GValue}s are heap allocated and managed my the memory manager, we no longer have control over where the values are located in memory. We must assume the location is arbitrary, and that \cn{GValue}s with temporal locality do not possess spatial locality. As we saw in Chapter \ref{chap:Background}, cache locality is paramount for performance.

\subsection{Inefficient storage usage}
\label{sub:Inefficient storage usage}
\cn{GValue}s have much storage overhead. First, since they are reference counted, each value contains a 4 byte integer. In addition, since a \cn{GValue} is a class type, the first 8 bytes in an object is a pointer to a virtual method table. At last, in order to access values, a pointer to the \cn{GValue} itself must also be stored, which is an additional 8 byte. Hence, for a 32-bit integer, only 4 out of 24 bytes are used to store the actual data.

Secondly, \cn{GValues} in a \cn{CompositionObjectValueCollection} does not apply compression. With the same reasoning as above, we see that each 1 byte boolean value in \gap~takes up 21 bytes when put into a \cn{GValue}. In theory, only 1 bit is needed for such value, and we studied techniques in Chapter \ref{chap:Background} how dictionary encoding and bitpacking can help acheive that. Reducing the memory per value from 21 bytes to 1 bit is a memory reduction of almost 200X.

We saw in the background section that compression and using storage efficiently can turn a process from I/O bound to CPU bound, and is extremely important for optimal performance.

\section{Research Motivation}
\label{sec:Research Motivation}
Now that we have established the relevant use cases for \genus, studied background theory in model-driven engineering and database technology, and analyzied \gap~source code, we may present the thesis motivation.

First of all, we observe that \gap~is in fact a sophisticated in-memory database with data that are persisted to SQL-supporting back-ends. The main difference is that \gap~has extensive knowledge about the data, or metadata, as well as full control over where and for what the data is used for. The platform knows more about the data than a regular database using the data interpretation, which databases are normally agnostic. We therefore conclude that theory from database technology can be applied to model-driven development and \gap, and that there is a large potential in the metadata.

\todo{Missing paragraph of how DB technology can solve our specific challenges?}

Our second observation is that we have a possibility to implement optimizations from the database technology in the method engineering layer without affecting the information system development layer. Much like a compiler optimizes code better and more reliable \cite{Selic2003-qa}, we see the potential in letting \gap~optimize without programmer or modeller intervention. In this thesis, we focus on the method engineering layer to improve performance for the end-users. We plan to implement our changes such that it affects the information system development layer as little as possible.
