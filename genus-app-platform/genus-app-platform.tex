\chapter{Genus App Platform}
\label{chap:Genus App Platform}

\gap~is a platform for software development that aims to increase developer productivity and simplyfy change management through model-driven development \cite{Genus_AS2016-kt}. End user applications are modeled using a modeling tool instead of being programmed. This enhances collaboration between business and IT, reduces life cycle costs, and lets the application developers focus on business logic instead of implementation details. \gap~uses generic software concepts on a higher level of abstraction than regular programming languages that are precise and non-ambigous \cite{noauthor_undated-qy}. These concepts, and the underlying implementation, have been refined and improved through years of trial and error on real customer use cases. The model contains enough detail to let \gap~run the application.

\gap~spans over three layers of model-driven development: The development of the platform itself is \textit{method engineering}, expert users using the modelling tool work on the \textit{information system development} layer, and the end users are in the \textit{information system} layer.


\section{Components and Architecture}
\label{sec:Components and Architecture}
\afigure{img/gap-components.png}{The components in \gap.}{fig:gap-components}{0.7}
A system developed with \gap~consists of four major components, as seen in Figure~\ref{fig:gap-components}.

\paragraph{Database Server}
\label{par:Database Server}
\gap~stores both the application models and the data for these models in one or more database servers. The platform can extend existing systems by building on top of existing database relations used in other applications, or define a completely new set tables for a new application. Since \gap~handles all integrety checks, validation rules, triggers, duplicates, and foreign keys, these constraints do not need to be defined at the database layer. \genus~has developed adapters for most major database vendors, including \pn{Oracle Database}, \pn{Microsoft SQL Server}, \pn{IBM DB2}, and \pn{MySQL}. 

\paragraph{Genus App Services}
\label{par:Genus App Services}
\pn{Genus App Services} is the server back-end in \gap. It facilitates communication between the client and the database server by multiplexing on application model, different data sets, and language \todo{Ønsker å fjerne språk, irrelevant for oppgaven}. It also handles authentication and session management. For simplicity and scalability, all \pn{Genus App Services} instances are stateless, which means that even though caching is used to improve performance, all servers may handle all responses. 

\paragraph{Genus Studio}
\label{par:Genus Studio}
\pn{Genus Studio} is the designer tool used by \gap~expert users. This is, in model-driven development terminology, the information system development layer, and the tool is used by modellers. In \pn{Genus Studio}, the customer's application is modelled with business logic using generic software concepts. The software runs on the \pn{Windows} platform.

\paragraph{Genus Desktop and Genus Apps}
\label{par:Genus Desktop and Genus Apps}
These are the end user clients for \pn{Windows} and mobile platforms respectively. In model-driven development terminology, this is the information system layer, and is used by the end users. End users access their applications with its respective data set through these clients. One running instance of these clients points to an application model and a dataset. They communicate with \pn{Genus App Services} for authentication and data, and the data received is kept in-memory in the client.

\section{Application Development}
\label{sec:Application Development}
In this section we study how an application is developed in \gap~using \pn{Genus Studio}. In the platform, there are three  different layers: Data layer, logic layer, and user interface layer.

\subsection{Data Layer}
\label{sub:Data Layer}
\afigure{img/gap-data-layer.png}{The data layer in \gap. There is built-in security in the framework, in addition to integrity, data validation, and calculation. Courtesy of \cite{Genus_AS2016-kt}.}{fig:gap-data-layer}{0.65}
In Figure \ref{fig:gap-data-layer}, we see the \gap~data layer. The data layer in an application consists of classes and properties, hierarchies (inheritance) and connections (relations). Schema is \todo{Hva er et schema?}... Each time some data is modified, it is checked for integrety and validity, and new calculations are made for formulas. In addition, events and rules is supported. The data layer is protected by security functionality that limits the access on certain objects or certain properties. The data layer with is modelled in a class diagram, which we will discuss in greater detail in Section \ref{sec:Concepts}.

\subsection{Logic Layer}
\label{sub:Logic Layer}
\afigure{img/gap-logic-layer.png}{Courtesy of \cite{Genus_AS2016-kt}.}{fig:gap-logic-layer}{1.0}
The main component in the logic layer is \textit{Action Orchestration}, where the logic is defined, or orchestrated, through programming launguage-like constructs, such as loops, ifs, and exceptions. There is a number of different actions, including object create, object delete, object modification, file creation, and IO operations like writing to files and consuming REST services. The Web Service \todo{Hva gjør Web Service i figuren?}... A task, defined by an action orchestration, can be run manually, but is more commonly triggered by elements in the user interface level, like a button press, or by other events like recurring events triggered by a timer. The logic layer is depicted in Figure \ref{fig:gap-logic-layer}.

%For our research, the most important parts of the logic layer is the object fetching and manipulation, as well as the data aggregate generation. We study this later in the thesis.

\subsection{User Interface Layer}
\label{sub:User Interface Layer}
\afigure{img/gap-user-interface-layer.png}{Courtesy of \cite{Genus_AS2016-kt}.}{fig:gap-user-interface-layer}{1.0}
The user interface layer, shown in Figure \ref{fig:gap-user-interface-layer}, defines a number of UI components to design an application. The two major components are form views and tables. A view interacts with the logic layer through invoking tasks. One form is designed for either \pn{Genus Desktop} or \pn{Genus Apps}.

\section{Concepts}
\label{sec:Concepts}
In this section we list some important concepts used in \gap.

\subsection{Object Classes}
\label{sub:Object Classes}
\afigure{img/gap-class-diagram.png}{Class diagram from \textit{Genus Studio} for the \tpch. Blue units represent object domain compositions which means they are mapped to a database table, and white units represent code domain compositions that are part of the application.}{fig:gap-class-diagram}{1.0}
An object class in \gap~is the hybrid between a table definition in a database and a class in a programming language, and is defined in the data layer. An object class, or a composition, includes several properties (see Section \ref{sec:Object Class Properties}), information on where the data is provided, integrety constraints, security settings, and other display options. An object class can either be based on one or more tables in a database, which we refer to as the \textit{object domain}, or based on a set of values modelled into the application, which is the \textit{code domain}. The objects are defined in a class diagram, which is illustrated in Figure \ref{fig:gap-class-diagram}.

\subsection{Object Class Properties}
\label{sub:Object Class Properties}
An object class is composed of one or more properties. Such properties can be simple data types, like integers and strings, or a function type, which calculates their value based on other properties in the class. In addition to the type definition, all properties also define a data interpretation. There exist a number of such interpretations, for instance \textit{file}, \textit{password}, \textit{date format}, and \textit{color}. A data interpretation can also be another object class, commonly used on foreign key fields, which creates a relation between the object classes. An object class property defines its own set of security rules, as well as validation and display options.

\subsection{Data Source}
\label{sub:Data Source}
A data source is an important concept in \gap, as it is used by tasks and user interface components to define which data should be accessible. Tasks and user interface components define one or more data sources that will provide data from the database, if needed. A data source contains either one object instance or multiple instances of an object class. Data from the database are normally brought up from the database at load time for the specific task or form. A data source stores its data in-memory. Empty data sources might also be defined such that objects can be moved from one source to another, or created, as a part of a task or on a form.

A data source might define a filter on which objects that should be loaded. This is directly translated to SQL, such that a data source will only receive objects that conforms to the filter.

\subsection{Data Mart}
\label{sub:Data Mart}
\afigure{img/gap-data-mart.png}{Data mart for Q1 in \tpch, which contains only the object classes and fields needed to answer that particular query. The mart conforms to a snowfalke schema.}{fig:gap-data-mart}{0.7}
A data mart defines a data extract that are used by \pn{Genus Discovery}, the integrated \bd~soulution within \gap. A data mart is defined by a set of data sources, and per data source, a list of published fields. Like always, a data source might specify a filter, such that the analyses access only a particular subset of the data.

Besides from the field and data source filtering, a data mart looks very much like like an object diagram, like seen in Figure \ref{fig:gap-data-mart}. Still, there is one important distinction: A data mart must conform to a snowflake schema, that is there can only exist one path through the class diagram. For instance, in Figure \ref{fig:gap-class-diagram}, both customer and suppliers refer to the nation table. In a data mart, there would two nation entitities, a \texttt{CUSTOMER\_NATION} and a \texttt{SUPPLIER\_NATION} table.

\subsection{Genus Discovery}
\label{sub:Genus Discovery}
\missingfigure{Genus discovery screenshot}
\pn{Genus Discovery} is the built-in \bd~solution in the platform. It is a graphical user interface component that builds on a data mart. Like most similar products, \pn{Genus Discovery} does not rely on aggregated data such that the user can follow his "information scent" and click his way through the data. An example user interface is seen in Figure \ref{fig:genus-discovery}.

\subsection{Task}
\label{sub:Task}
\afigure{img/gap-task.png}{A task definition in \gap. A task may read from and to data sources, enumerate using for or while loops, consume services, import, export, and more.}{fig:gap-task}{1.0}
A task in \gap~is similar to a procedure or a function in a programming language, and is defined at the logic layer. A task might be triggered manually, or through user interaction in the user interface, or by agents that trigger tasks periodically.

As seen in Figure \ref{fig:gap-task}, the users might specify specific steps that loads data sources, filters, modifies attributes, imports, exports, and more.

\section{Source Code and Classes}
\label{sec:Source Code and Classes}
\afigure{img/gap-original-class-diagram.png}{\gap~class diagram}{fig:gap-original-class-diagram}{0.8}
The core of \gap~is written in \delphi, the programming language we discussed in Section \ref{sec:The Delphi Programming Language}. In this section we list the most important classes in the source code, and how it relates to the concepts from Section \ref{sec:Concepts}. A simplified class diagram is shown in Figure \ref{fig:gap-original-class-diagram}.

\subsection{GValue}
\label{sub:GValue}
The \cn{GValue} class, short for \textit{Genus Value} is a base class that can contain any value of any type that is supported in the platform. These types include integers, floating point numbers, strings, object handles, dates, and more. The \cn{GValue} class is a necessity in \gap~to omit the rigid type system in \delphi~such that all values can be handled the same way. The class contains comparison methods and utility functions for type conversions. The \cn{GValue} type is used in both information system and information system development layers.

For all value type supported in the system, there are get and set methods for that specific value type defined in the base class. These methods are not implemented in the \cn{GValue} class, but by subclasses defined for the various data types. For instance, there exists a \cn{IntegerValue} that extends \cn{GValue} which overrides the \cn{GetAsInteger} and \cn{SetAsInteger} methods. Each subclass also contains a member variable to store the actual data.

% memory handling
A \cn{GValue} is a class type and not a record type, hence is allocated by the memory manager and put on the heap. The \cn{GValue} has built-in reference counting to enable cloning.

\subsection{CompositionDescriptor and CompositionObject}
\label{sub:CompositionDescriptor}
The object class, or composition, which we discussed in Section \ref{sub:Object Classes}, is represented through the \cn{CompositionDescriptor} and \cn{CompositionObject} classes. Since \gap~source code is developed in one layer of abstraction above a regular programming language, we need two classes to support compositions, as we see in Figure \ref{fig:linguistic-metamodeling}. The relationship between the descriptor and the object is normally built into the language as classes and objects, but in a model-driven framework, there must be two explicit constructs.

The \cn{CompositionDescriptor} class describes a composition, and represents an object class. Conceptually, such descriptor is the same as a class in a programming language. As described Section \ref{sub:Object Classes}, a composition descriptor contains a list of data descriptors as well as ... \todo{Trenger hjelp her}. A composition descriptor contains data from the information system delevopment layer.

The \cn{CompositionObject} class represents object instances for object classes. Each object has a reference to its composition descriptor, and in addition, there are other variables that store object state, validation errors, formatting, and more. The properties and data belonging to a composition object instance is stored in a \cn{CompositionObjectValueCollection} class, which we study in Section \ref{sub:CompositionObjectValueCollection}.


\subsection{DataDescriptor}
\label{sub:DataDescriptor}
The \cn{DataDescriptor} class describes an attribute in a composition, which is the object class property we studied in Section \ref{sub:Object Class Properties}. It holds all revelant data about a property, mainly type and representation, but also constraints and formatting rules. Instances of the \cn{DataDescriptor} class exist in the information system development layer.

\subsection{CompositionObjectValueCollection}
\label{sub:CompositionObjectValueCollection}
The \cn{CompositionObjectValueCollection} class holds the data for composition objects, and is equivalent to the data stored in class properties in a regular programming language. Alternatively, this collection class can be thought of as a row in a DBMS. The class contains a list of \cn{GValue}s and a list of \cn{DataDescriptor}s. Values are accessed through querying the \cn{CompositionObjectValueCollection} with a \cn{DataDescriptor}, where the correct value is found using a linear search through the list.

\begin{table}
    \begin{tabularx}{\textwidth}{X | X | X}
        Class Name & Concept & Model-driven development layer \\
        \hline
        \hline
        \cn{GValue} & - & Method engineering layer \\
        \hline
        \cn{CompositionDescriptor} & Object Class & Information system development layer \\
        \hline
        \cn{CompositionObject} & Instance of Object Class & Information system layer \\
        \hline
        \cn{DataDescriptor} & Object Class Property & Information system development layer \\
        \hline
        \cn{CompositionObject- ValueCollection} & Values of Object Class Property & Information system layer
    \end{tabularx}
    \caption{Classes and layers}
    \label{tab:concept-class-mapping}
\end{table}

An overview over classes, and how they relate to \gap~concepts and model-driven engineering layers is found in Table \ref{tab:concept-class-mapping}.

\section{Challenges in Genus App Platform}
\label{sec:Challenges in Genus App Platform}
There is a number of challenges in the current design of \gap. The main focus of the source code has been to have a readable code that is easy to maintain \todo{Stemmer dette?}. However, making code readable and mainainable have lead to an implementation that is not optimized for performance. In this section, we discuss some of the challenges in \gap, which are related to memory usage and memory access.

\subsection{Excessive amount of pointers}
\label{sub:Excessive amount of pointers}
\afigure{img/gap-original-instantiation.png}{Pointers in \gap. For every object, there is not only a list to the values, but also a list to the corresponding data descriptors.}{fig:gap-original-instantiation}{0.8}
One of the main challenges in \gap~is the large amount of pointers needed to store object data. As we saw in Section \ref{sub:CompositionObjectValueCollection}, each \cn{CompositionObjectValueCollection} not only stores \cn{GValue}s containing the data, but but also pointers to all data descriptors. Although this implementation is flexible because every value collection is self-contained and objects can have a variable number of fields lodaded, the overhead for storing all these pointers is substantial. This is especially true on a 64-bit architecture, where each pointer uses 8 bytes. The pointers are indicated as arrows in Figure \ref{fig:gap-original-instantiation}.

We study the pointer overhead by using a simple example. We assume an object class with 15 class properties. In the data source there are 1,000,000 million elements. Here, we see the amount of pointers needed:
\begin{itemize}
    \item \textbf{1 pointer}, for the data source.
    \item \textbf{2 pointers}, for the composition descriptor and the pointer to the list of data descriptors.
    \item \textbf{15 pointers}, for the composition data descriptors
    \item Then, for every object:
    \begin{itemize}
        \item \textbf{1 pointer}, for the composition object.
        \item \textbf{1 pointer}, for the value collection pointer.
        \item \textbf{15 pointers}, for all data descriptors in the value collection.
        \item \textbf{15 pointers}, for all values in the value collection.
    \end{itemize}
\end{itemize}
This results in 32,000,018 pointers, which is roughly 244mb on a 64-bit architecture. Keep in mind that this number only contains storage used for pointers, not the actual data itself. If all values are 32-bit integers, the raw data itself would only take up approximately 57mb, which in this example is only 20\% of the pointers.

\subsection{Ineficcient Data Access and Poor Memory Locality}
\label{sub:Ineficcient Data Access and Poor Memory Locality}
Commonly in \gap, there are operations that perform calculations or evaluate predicates on a large number of values. These operations access many values in tight loops, and it is not uncommon they scan all values for a given data descriptor in a data source. For instance, an operation that sums up all numbers for an object property in a data source would for every iteration do the following:
\begin{itemize}
    \item The \cn{CompositionObjectValueCollection} is scanned linearly for the correct data descriptor.
    \item The corresponding \cn{GValue} is found, and the accessor method (i.e. \fn{GetAsInteger}) is looked up in the dispatch table.
    \item A new stack frame is put on the stack to run the \fn{GetAsInteger} method.
\end{itemize}

Although the compiler might be able to optimize some of the steps above, it is far from ideal. For instance, the accessor method for the value is virtual and cannot be inlined. As we saw in Section \ref{sec:Background Information on Modern CPUs and Compilers}, the difference between minimal and maximal CPU utilization can easily be one order of magnitude, where branches and new stack frames may severely hurt performance. Last, the linear search through data descriptors hurts performance.

Not only is the data access pattern complex, we may also assume poor memory locality. As \cn{GValue}s are heap allocated and managed my the memory manager, we no longer have control over where the values are located in memory. We must assume the location is arbitrary, and that \cn{GValue}s with temporal locality do not possess spatial locality. As we saw in Chapter \ref{chap:Background}, cache locality is paramount for performance.

\subsection{Inefficient storage usage}
\label{sub:Inefficient storage usage}
\cn{GValue}s have much storage overhead. First, since they are reference counted, each value contains a 4 byte integer. In addition, since a \cn{GValue} is a class type, the first 8 bytes in an object is a pointer to a virtual method table. At last, in order to access values, a pointer to the \cn{GValue} itself must also be stored, which is an additional 8 byte. Hence, for a 32-bit integer, only 4 out of 24 bytes are used to store the actual data.

Secondly, \cn{GValues} in a \cn{CompositionObjectValueCollection} does not apply compression. With the same reasoning as above, we see that each 1 byte boolean value in \gap~takes up 21 bytes when put into a \cn{GValue}. In theory, only 1 bit is needed for such value, and we studied techniques in Chapter \ref{chap:Background} how dictionary encoding and bitpacking can help acheive that. Reducing the memory per value from 21 bytes to 1 bit is a memory reduction of almost 200X.

We saw in the background section that compression and using storage efficiently can turn a process from I/O bound to CPU bound, and is extremely important for optimal performance.

\section{Chapter Conclusion and Thesis Motivation}
\label{sec:Chapter Conclusion and Thesis Motivation}
Now that we have established the relevant use cases for \genus, studied background theory in model-driven engineering and database technology, and analyzied \gap~source code, we may present the thesis motivation.

First of all, we observe that \gap~is in fact a sophisticated in-memory database with data that are persisted to SQL-supporting back-ends. The main difference is that \gap~has extensive knowledge about the data, or metadata, as well as full control over where and for what the data is used for. The platform knows more about the data than a regular database using the data interpretation, which databases are normally agnostic. We therefore conclude that theory from database technology can be applied to model-driven development and \gap, and that there is a large potential in the metadata.

\todo{Missing paragraph of how DB technology can solve our specific challenges?}

Our second observation is that we have a possibility to implement optimizations from the database technology in the method engineering layer without affecting the information system development layer. Much like a compiler optimizes code better and more reliable \cite{Selic2003-qa}, we see the potential in letting \gap~optimize without programmer or modeller intervention. In this thesis, we focus on the method engineering layer to improve performance for the end-users. We plan to implement our changes such that it affects the information system development layer as little as possible.
