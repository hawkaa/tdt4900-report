\chapter{Genus App Platform}
\label{chap:Genus App Platform}

\gap~is a platform for software development that aims to increase developer productivity and simplyfy change management through model-driven development \cite{Genus_AS2016-kt}. End user applications are modeled using a modeling tool instead of being programmed. This enhances collaboration between business and IT, reduces life cycle costs, and lets the application developers focus on business logic instead of implementation details. \gap~uses generic software concepts on a higher level of abstraction than regular programming languages that are precise and non-ambigous \cite{noauthor_undated-qy}. These concepts, and the underlying implementation, have been refined and improved through years of trial and error on real customer use cases. The model contains enough detail to let \gap~run the application.


\section{Components and Architecture}
\label{sec:Components and Architecture}
\afigure{img/gap-components.png}{The components in \gap.}{fig:gap-components}{0.7}
A system developed with \gap~consists of four major components, as seen in Figure~\ref{fig:gap-components}.

\paragraph{Database Server}
\label{par:Database Server}
\gap~stores both the application models and the data used by such these models in one or more database servers. The platform can extend existing systems by building on top of existing database relations used in other applications, or define new tables. Since \gap~handles all integrety checks, validation rules, triggers, duplicates, and foreign keys, these constraints do not need to be defined at the database layer. \genus~has developed adapters for most major database vendors, including \pn{Oracle Database}, \pn{Microsoft SQL Server}, \pn{IBM DB2}, and \pn{MySQL}. 

\paragraph{Genus Server}
\label{par:Genus Server}
\pn{Genus Server} is the back-end in \gap. It facilitates communication between the client and the database server by multiplexing on application model, different data sets, and language \todo{Remove language, as it is irrelevant for all discussion?}. It also handles authentication and session management. For simplicity and scalability, all \pn{Genus Server} are stateless. Even though caching is used to improve performance, all servers may handle all responses. 

\paragraph{Genus Studio}
\label{par:Genus Studio}
\pn{Genus Studio} is the designer tool used by expert \gap~users. This is, in model-driven development terminology, the information system development layer. In \pn{Genus Studio}, the customer's application is modelled with business logig using generic software concepts. The software runs on the \pn{Windows} platform. We study \pn{Genus Studio} in greater detail later in this chapter.

\paragraph{Genus Desktop and Genus Apps}
\label{par:Genus Desktop and Genus Apps}
These are the end user clients for \pn{Windows} and mobile platforms respectively. In model-driven development terminology, this is the information system layer. End users access their applications with its respective data set through these clients. One running instance of these clients points to an application model and a dataset. They query \pn{Genus Studio} for data, and when the data arrives at the client, it is kept in-memory.

In our research, we focus on \pn{Genus Client} and \pn{Genus Studio}.


\section{Application Development}
\label{sec:Application Development}
In this section we study how an application is developed using \gap. \genus~define three different layers: User interface, logic, and data layer. The applications are modelled using \pn{Genus Studio}.

\subsection{Data Layer}
\label{sub:Data Layer}
\afigure{img/gap-data-layer.png}{The data layers in \gap. There is built-in security in the framework, in addition to integrity, data validation, and calculation. Courtesy of \cite{Genus_AS2016-kt}.}{fig:gap-data-layer}{0.65}
In Figure \ref{fig:gap-data-layer}, we see how \gap~handles the data layer. The data layer in an application created using \gap~consists of classes and properties, hierarchies (inheritance) and connections (relations). Schema is \todo{Hva er et schema?}... Data flows through the system using an integrety, validation, and calculation engine. In addition, events and rules is supported. The entire data layer is protected by a security layer that gives access to only certain properties or certain objects. Data is modelled in a class diagram, which we will discuss in greater detail in Section \ref{sec:Concepts}.

% important
We observe that the way \genus~has chosen to implement their software is actually an in-memory database that are persisted to database backends supporting SQL. This is an important observation in our research.

\subsection{Logic Layer}
\label{sub:Logic Layer}
\afigure{img/gap-logic-layer.png}{Courtesy of \cite{Genus_AS2016-kt}.}{fig:gap-logic-layer}{1.0}
The main component in the logic layer is the action orchestration, where the logic is defined, or orchestrated, through programming launguage-like constructs, like loops, ifs,  and exceptions. There is a number of different actions, including object create, object delete, modify objects, file creation, and IO operations like files and REST services. The Web Service \todo{Hva gj√∏r Web Service i figuren?}... A task, defined by an action orchestration, can be run manually, but more commonly triggered by elements in the user interface level, or by other events like recurring time events. The logic layer is depicted in Figure \ref{fig:gap-logic-layer}.

For our research, the most important parts of the logic layer is the object fetching and manipulation, as well as the data aggregate generation. We study this later in the thesis.

\subsection{User Interface Layer}
\label{sub:User Interface Layer}
\afigure{img/gap-user-interface-layer.png}{Courtesy of \cite{Genus_AS2016-kt}.}{fig:gap-user-interface-layer}{1.0}
The user interface layer, shown in Figure \cite{fig:gap-user-interface-layer}, defines a number of UI components to design an application. The two major components are form views and tables. A view interacts with the logic layer through invoking tasks. One form is designed for either \pn{Genus Desktop} or \pn{Genus Apps}.

\section{Concepts}
\label{sec:Concepts}
In this section we enumerate some important concepts that are used in \gap.

\subsection{Object Classes}
\label{sub:Object Classes}
\afigure{img/gap-class-diagram.png}{Class diagram in \gap for the \tpch. Blue units represent object domain compositions which means they are mapped to a database table, and white units represent code domain compositions that are part of the application.}{fig:gap-class-diagram}{1.0}
An object class in \gap~is the hybrid between a table definition in a database and a class in a programming language, and is defined in the data layer. An object class, or a composition, includes several properties (see Section \ref{sec:Object Class Properties}), information on where the data is provided, integrety constraints, security settings, and other display options. An object class can either be based on one or more tables in a database, which we refer to as the \textit{object domain}, or based on a set of values modelled into the application, which is the \textit{code domain}. The objects are defined in a class diagram, which is illustrated in Figure \ref{fig:gap-class-diagram}.

\subsection{Object Class Properties}
\label{sec:Object Class Properties}
An object class is composed of one or more properties. Such properties can be simple data types, like integers and strings, or a function type, which calculates their value based on other properties in the class. In addition to the type definition, all properties also define a data interpretation. Such interpretations include \textit{file}, \textit{password}, \textit{date format}, and \textit{color}. A data interpretation can also be another object class, commonly used on foreign key fields, which creates a relation between the object classes.

An object class property defines its own set of security rules, as well as validation and display options.

\subsection{Data Source}
\label{sub:Data Source}
A data source is an important concept in \gap, as it is used by tasks and user interface components to define which data should be accessible. Tasks and user interface components define one or more data sources that will provide data from the database, if needed. A data source contains either one object instance or multiple instances of an object class. Data from the database are normally brought up from the database at load time for the specific task or form. A data source stores its data in-memory. Empty data sources might also be defined such that objects can be moved from one source to another during a task or on a form.

A data source might define a filter on which objects that should be loaded. This is directly translated to SQL, such that a data source will only receive objects that conforms to the filter.

\subsection{Data Mart}
\label{sub:Data Mart}
\afigure{img/gap-data-mart.png}{Data mart for Q1 in \tpch, which contains only the object classes and fields needed to answer that particular query. The mart conforms to a snowfalke schema.}{fig:gap-data-mart}{0.7}
A data mart defines a data extract that are used in analyses and \bd~panels in \gap. A data mart is defined by a set of data sources, and per data source, a list of published fields. Like always, a data source might specify a filter, such that the analyses access only a particular subset of the data.

Besides from the field and data source filtering, a data mart looks very much like like an object diagram, like seen in Figure \ref{fig:gap-data-mart}. Still, there is one important distinction: A data mart must conform to a snowflake schema, that is there can only exist one path through the class diagram. For instance, in Figure \ref{fig:gap-class-diagram}, both customer and suppliers refer to the nation table. In a data mart, there would two nation entitities, a \texttt{CUSTOMER\_NATION} and a \texttt{SUPPLIER\_NATION} table.

\subsection{Task}
\label{sub:Task}
\afigure{img/gap-task.png}{A task definition in \gap. A task may read from and to data sources, enumerate using for or while loops, consume services, import, export, etc. This specific task enumerates lineitems in the \tpch~and modifies some properties.}{fig:gap-task}{1.0}
A task in \gap~is similar to a procedure or a function in a programming language, and is defined at the logic layer. A task might be triggered manually, or through user interaction in the user interface, or by agents that trigger tasks periodically.

As seen in Figure \ref{fig:gap-task}, the users might specify specific steps that loads data sources, filters, modifies attributes, imports, exports, and more.

\section{Source Code and Classes}
\label{sec:Source Code and Classes}
\afigure{img/gap-original-class-diagram.png}{\gap~class diagram}{fig:gap-original-class-diagram}{0.8}
The \gap~core is written in Delphi, a programming language we discussed in Section \ref{sec:The Delphi Programming Language}. In this section we enumerate the most important classes in the source code, and how it relates to the concepts from Section \ref{sec:Concepts}. A simplified class diagram is shown in \ref{fig:gap-original-class-diagram}.

\subsection{GValue}
\label{sub:GValue}
The \cn{GValue} class, short for \textit{Genus Value} is a base class that can contain any value of any type that is supported in the platform. These types include integers, floating point numbers, strings, object handles, dates, and more. The \cn{GValue} class is a necessity in \gap~to omit the \delphi~rigid type system and to handle all values the same way. In addition, there are comparison methods and utilities for class conversion.

For ever value type supported in the system, there exists accessor methods for that value type, that throws an exception by default. For instance, \fn{GetAsInteger} is implemented in \cn{GValue} class, but it throws an exception. There exists a \cn{IntegerValue} that overrides this function and returns the actual value.

% memory handling
A \cn{GValue} is a class type and not a record type, hence is allocated on the heap. The \cn{GValue} has built-in reference counting such that \fn{Clone} will not make an actual copy, only increment.

% The different \cn{GValue} types inherit from from the base class and override methods that make sense. All inn all, it contains a refcount and the actual value.

\subsection{CompositionDescriptor and CompositionObject}
\label{sub:CompositionDescriptor}
The object class, or composition, which we discussed in Section \ref{sub:Object Classes}, is represented through the \cn{CompositionDescriptor} and \cn{CompositionObject} classes. Since \gap~source code is developed in one layer of abstraction above a regular programming language, we need two classes to support compositions, as we see in Figure \ref{fig:linguistic-metamodeling}. The relationship between the descriptor and the object is normally built into the language as classes and objects, but in a model-driven framework, there must be two explicit constructs.

The \cn{CompositionDescriptor} class describes a composition, and represents an object class. Conceptually, such descriptor is the same as a class in a programming language. As described Section \ref{sec:Object Classes}, a composition descriptor contains a list of data descriptors as well as ... \todo{Trenger hjelp her}. A composition descriptor contains data from the information system delevopment layer.

The \cn{CompositionObject} class represents object instances for object classes. Each object has a reference to its composition descriptor, and in addition, there are other variables that store object state, validation errors, formatting, and more. The data belonging to a composition object is stored in a \cn{CompositionObjectValueCollection} class (Section \ref{sub:CompositionObjectValueCollection}).


\subsection{DataDescriptor}
\label{sub:DataDescriptor}
The \cn{DataDescriptor} class describes an attribute in a composition, which is the object class property we studied in Section \ref{sub:Object Class Properties}. It holds all revelant data about a property, mainly type and representation, but also constraints and formatting rules. Instances of the \cn{DataDescriptor} class exist in the information system development layer.

\subsection{CompositionObjectValueCollection}
\label{sub:CompositionObjectValueCollection}
The \cn{CompositionObjectValueCollection} class holds the data for composition objects, and is equivalent to the data stored in class properties in a regular programming language. Alternatively, this collection class can be thought of as a row in a DBMS. The class contains a list of \cn{GValue} and a list of \cn{DataDescriptor}. Values are accessed through querying the \cn{CompositionObjectValueCollection} with a \cn{DataDescriptor}.

\begin{table}
    \begin{tabularx}{\textwidth}{X | X | X}
        Class Name & Concept & Model-driven development layer \\
        \hline
        \hline
        \cn{GValue} & - & Method engineering layer \\
        \hline
        \cn{CompositionDescriptor} & Object Class & Information system development layer \\
        \hline
        \cn{CompositionObject} & Instance of Object Class & Information system layer \\
        \hline
        \cn{DataDescriptor} & Object Class Property & Information system development layer \\
        \hline
        \cn{CompositionObject- ValueCollection} & Values of Object Class Property & Information system layer
    \end{tabularx}
    \caption{Classes and layers}
    \label{tab:concept-class-mapping}
\end{table}

An overview over classes, and how they relate to \gap~concepts and model-driven engineering layers is found in Table \ref{tab:concept-class-mapping}.

\section{Challenges in Genus App Platform}
\label{sec:Challenges in Genus App Platform}
There is a number of challenges in \gap~in the way it is designed. In this section, we discuss some of these challenges, which are related to memory usage and memory access.

\subsection{Excessive amount of pointers}
\label{sub:Excessive amount of pointers}
\afigure{img/gap-original-instantiation.png}{Many pointers in the original implementation of \gap}{fig:gap-original-instantiation}{0.7}
The current implementation has a large amount of pointers, as seen in Figure \ref{fig:gap-original-instantiation}. On a 64 bit architecture, which is the case for \gap, each pointer is 8 bytes, which can be sufficient to drastically increase the memory usage.

Lets take a simplified example. We have a data source with a composition. The composition has 15 fields, and in the data source there are 1,000,000 million elements.
\begin{itemize}
    \item \textbf{3 pointers} For the Data source, composition and a pointer to the list of data descriptors.
    \item \textbf{15 pointers} For the composition data descriptors
    \item \textbf{1 + 15 + 15 = 31 pointers} per composition object. One for value collection, the rest is all the data descriptors and all the values.
\end{itemize}

This results in 31,000,018 pointers, which is roughly 236mb. And this is only pointers, not including the data itself. If each element is a 4 byte integer, the total data size is only 57mb which in this example only comprise 20\% of the total storage.

\subsection{Ineficcient data access and memory locality}
\label{sub:Ineficcient data access and memory locality}
Data in a \cn{GValue} are inefficiently accessed. Say, if you have a list of \cn{GValue} integers that you want to sum, for every element:
\begin{itemize}
    \item The \cn{GValue} has to be dereferenced.
    \item The correct \fn{GetAsInteger} method would have to be looked up in the dispatch table.
    \item A new stack frame is put on the stack to run the \fn{GetAsInteger} method.
\end{itemize}
Since the method is virtual, the compiler is unable to inline the function, hence, a new stack frame and register flush is required on every access. This differs dramatically from a normal loop iteration where a pointer is increased for every operation.

Secondly, data locality degrades as we have lost control over the memory and handed it over to the memory manager. On every constructor call, memory is allocated on the heap, on a position we must assume is arbitrary. As we read in Chapter \ref{chap:Background}, cache locality is one of the key ingredients in database performance.

Third, a linear search is performed in the value collection every time. In terms of computational complexity, a linear search is still contant, but this adds to the overhead on looking up a single attribute.

\subsection{Inefficient storage usage}
\label{sub:Inefficient storage usage}
This is related to the previous sections, but for each value that is stored, an 8 byte pointer, a 4 byte ref-count and the actual value itself is stored. Depending on the data size, the overhead is commonly larger than the value itself.

Theoretically, a boolean needs only a bit to be stored. In the \cn{GValue} class, a boolean takes 8 + 4 + 1 = 13 bytes = 104bits. Hence, the theoretical space saving for such value is roughly 100 times smaller.

\section{Chapter Conclusion}
\label{sec:Chapter Conclusion}
To recap, we see three layers of model-driven development in the \gap~architecture:
\begin{itemize}
    \item \bf{Information system layer} for end-users. They use \pn{Genus Desktop} and \pn{Genus Apps} to add, modify and delete data in their business application.
    \item \bf{Information Systed Development Layer} for \gap~expert users. They use \pn{Genus Studio} to develop business applications for end users.
    \item \bf{Method Engineering Layer} for \gap~developers. 
\end{itemize}
In this thesis, we focus on the method engineering layer to improve performance for the end-users. We plan to implement our changes such that it affects the information system development layer as little as possible.

Our main motivation for the research is to investigate the intersection between the two fields: Database technology and model-driven development.

\gap~knows more about the data than a regular database using the data interpretation, which databases are normally agnostic.

In other words, a data source is an in-memory storage for object classes.

We will see later in this thesis that data sources used many places in \gap~and its implementation is important for overall performance and memory usage.
