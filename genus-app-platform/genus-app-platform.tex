\chapter{Genus App Platform}
\label{chap:Genus App Platform}

\gap~is a platform for software development that aims to increase developer productivity and simplyfy change management through model-driven development \cite{Genus_AS2016-kt}. End user applications are modeled using a modeling tool instead of being programmed. This enhances collaboration between business and IT, reduces life cycle costs, and lets the application developers focus on business logic instead of implementation details. \gap~uses generic software concepts on a higher level of abstraction than regular programming languages that are precise and non-ambigous \cite{noauthor_undated-qy}. These concepts, and the underlying implementation, have been refined and improved through years of trial and error on real customer use cases. The model contains enough detail to let \gap~run the application.

\gap~spans over three layers of model-driven development: The development of the platform itself is \textit{method engineering}, expert users using the modelling tool work on the \textit{information system development} layer, and the end users are in the \textit{information system} layer.


\section{Components and Architecture}
\label{sec:Components and Architecture}
\afigure{img/gap-components.png}{The components in \gap.}{fig:gap-components}{0.7}
A system developed with \gap~consists of four major components, as seen in Figure~\ref{fig:gap-components}.

\paragraph{Database Server}
\label{par:Database Server}
\gap~stores both the application models and the data used by such these models in one or more database servers. The platform can extend existing systems by building on top of existing database relations used in other applications, or define new tables. Since \gap~handles all integrety checks, validation rules, triggers, duplicates, and foreign keys, these constraints do not need to be defined at the database layer. \genus~has developed adapters for most major database vendors, including \pn{Oracle Database}, \pn{Microsoft SQL Server}, \pn{IBM DB2}, and \pn{MySQL}. 

\paragraph{Genus Server}
\label{par:Genus Server}
\pn{Genus Server} is the back-end in \gap. It facilitates communication between the client and the database server by multiplexing on application model, different data sets, and language \todo{Remove language, as it is irrelevant for all discussion?}. It also handles authentication and session management. For simplicity and scalability, all \pn{Genus Server} are stateless. Even though caching is used to improve performance, all servers may handle all responses. 

\paragraph{Genus Studio}
\label{par:Genus Studio}
\pn{Genus Studio} is the designer tool used by expert \gap~users. This is, in model-driven development terminology, the information system development layer, and the tool is used by modellers and \gap~expert user. In \pn{Genus Studio}, the customer's application is modelled with business logig using generic software concepts. The software runs on the \pn{Windows} platform. We study \pn{Genus Studio} in greater detail later in this chapter.

\paragraph{Genus Desktop and Genus Apps}
\label{par:Genus Desktop and Genus Apps}
These are the end user clients for \pn{Windows} and mobile platforms respectively. In model-driven development terminology, this is the information system layer, and is used by the end users. End users access their applications with its respective data set through these clients. One running instance of these clients points to an application model and a dataset. They query \pn{Genus Studio} for data, and when the data arrives at the client, it is kept in-memory.

In our research, we focus on \pn{Genus Client} and \pn{Genus Studio}.


\section{Application Development}
\label{sec:Application Development}
In this section we study how an application is developed using \gap. \genus~define three different layers: User interface, logic, and data layer. The applications are modelled using \pn{Genus Studio}.

\subsection{Data Layer}
\label{sub:Data Layer}
\afigure{img/gap-data-layer.png}{The data layers in \gap. There is built-in security in the framework, in addition to integrity, data validation, and calculation. Courtesy of \cite{Genus_AS2016-kt}.}{fig:gap-data-layer}{0.65}
In Figure \ref{fig:gap-data-layer}, we see how \gap~handles the data layer. The data layer in an application created using \gap~consists of classes and properties, hierarchies (inheritance) and connections (relations). Schema is \todo{Hva er et schema?}... Data flows through the system using an integrety, validation, and calculation engine. In addition, events and rules is supported. The entire data layer is protected by a security layer that gives access to only certain properties or certain objects. Data is modelled in a class diagram, which we will discuss in greater detail in Section \ref{sec:Concepts}.

\subsection{Logic Layer}
\label{sub:Logic Layer}
\afigure{img/gap-logic-layer.png}{Courtesy of \cite{Genus_AS2016-kt}.}{fig:gap-logic-layer}{1.0}
The main component in the logic layer is the action orchestration, where the logic is defined, or orchestrated, through programming launguage-like constructs, like loops, ifs,  and exceptions. There is a number of different actions, including object create, object delete, modify objects, file creation, and IO operations like files and REST services. The Web Service \todo{Hva gj√∏r Web Service i figuren?}... A task, defined by an action orchestration, can be run manually, but more commonly triggered by elements in the user interface level, or by other events like recurring time events. The logic layer is depicted in Figure \ref{fig:gap-logic-layer}.

For our research, the most important parts of the logic layer is the object fetching and manipulation, as well as the data aggregate generation. We study this later in the thesis.

\subsection{User Interface Layer}
\label{sub:User Interface Layer}
\afigure{img/gap-user-interface-layer.png}{Courtesy of \cite{Genus_AS2016-kt}.}{fig:gap-user-interface-layer}{1.0}
The user interface layer, shown in Figure \cite{fig:gap-user-interface-layer}, defines a number of UI components to design an application. The two major components are form views and tables. A view interacts with the logic layer through invoking tasks. One form is designed for either \pn{Genus Desktop} or \pn{Genus Apps}.

\section{Concepts}
\label{sec:Concepts}
In this section we enumerate some important concepts that are used in \gap.

\subsection{Object Classes}
\label{sub:Object Classes}
\afigure{img/gap-class-diagram.png}{Class diagram in \gap for the \tpch. Blue units represent object domain compositions which means they are mapped to a database table, and white units represent code domain compositions that are part of the application.}{fig:gap-class-diagram}{1.0}
An object class in \gap~is the hybrid between a table definition in a database and a class in a programming language, and is defined in the data layer. An object class, or a composition, includes several properties (see Section \ref{sec:Object Class Properties}), information on where the data is provided, integrety constraints, security settings, and other display options. An object class can either be based on one or more tables in a database, which we refer to as the \textit{object domain}, or based on a set of values modelled into the application, which is the \textit{code domain}. The objects are defined in a class diagram, which is illustrated in Figure \ref{fig:gap-class-diagram}.

\subsection{Object Class Properties}
\label{sub:Object Class Properties}
An object class is composed of one or more properties. Such properties can be simple data types, like integers and strings, or a function type, which calculates their value based on other properties in the class. In addition to the type definition, all properties also define a data interpretation. Such interpretations include \textit{file}, \textit{password}, \textit{date format}, and \textit{color}. A data interpretation can also be another object class, commonly used on foreign key fields, which creates a relation between the object classes.

An object class property defines its own set of security rules, as well as validation and display options.

\subsection{Data Source}
\label{sub:Data Source}
A data source is an important concept in \gap, as it is used by tasks and user interface components to define which data should be accessible. Tasks and user interface components define one or more data sources that will provide data from the database, if needed. A data source contains either one object instance or multiple instances of an object class. Data from the database are normally brought up from the database at load time for the specific task or form. A data source stores its data in-memory. Empty data sources might also be defined such that objects can be moved from one source to another during a task or on a form.

A data source might define a filter on which objects that should be loaded. This is directly translated to SQL, such that a data source will only receive objects that conforms to the filter.

\subsection{Data Mart}
\label{sub:Data Mart}
\afigure{img/gap-data-mart.png}{Data mart for Q1 in \tpch, which contains only the object classes and fields needed to answer that particular query. The mart conforms to a snowfalke schema.}{fig:gap-data-mart}{0.7}
A data mart defines a data extract that are used in analyses and \bd~panels in \gap. A data mart is defined by a set of data sources, and per data source, a list of published fields. Like always, a data source might specify a filter, such that the analyses access only a particular subset of the data.

Besides from the field and data source filtering, a data mart looks very much like like an object diagram, like seen in Figure \ref{fig:gap-data-mart}. Still, there is one important distinction: A data mart must conform to a snowflake schema, that is there can only exist one path through the class diagram. For instance, in Figure \ref{fig:gap-class-diagram}, both customer and suppliers refer to the nation table. In a data mart, there would two nation entitities, a \texttt{CUSTOMER\_NATION} and a \texttt{SUPPLIER\_NATION} table.

\subsection{Task}
\label{sub:Task}
\afigure{img/gap-task.png}{A task definition in \gap. A task may read from and to data sources, enumerate using for or while loops, consume services, import, export, etc. This specific task enumerates lineitems in the \tpch~and modifies some properties.}{fig:gap-task}{1.0}
A task in \gap~is similar to a procedure or a function in a programming language, and is defined at the logic layer. A task might be triggered manually, or through user interaction in the user interface, or by agents that trigger tasks periodically.

As seen in Figure \ref{fig:gap-task}, the users might specify specific steps that loads data sources, filters, modifies attributes, imports, exports, and more.

\section{Source Code and Classes}
\label{sec:Source Code and Classes}
\afigure{img/gap-original-class-diagram.png}{\gap~class diagram}{fig:gap-original-class-diagram}{0.8}
The \gap~core is written in Delphi, a programming language we discussed in Section \ref{sec:The Delphi Programming Language}. In this section we enumerate the most important classes in the source code, and how it relates to the concepts from Section \ref{sec:Concepts}. A simplified class diagram is shown in \ref{fig:gap-original-class-diagram}.

\subsection{GValue}
\label{sub:GValue}
The \cn{GValue} class, short for \textit{Genus Value} is a base class that can contain any value of any type that is supported in the platform. These types include integers, floating point numbers, strings, object handles, dates, and more. The \cn{GValue} class is a necessity in \gap~to omit the \delphi~rigid type system and to handle all values the same way. In addition, there are comparison methods and utilities for class conversion. A \cn{GValue} is used in both information system and information system development layers.

For ever value type supported in the system, there exists accessor methods for that value type, that throws an exception by default. For instance, \fn{GetAsInteger} is implemented in \cn{GValue} class, but it throws an exception. There exists a \cn{IntegerValue} that overrides this function and returns the actual value.

% memory handling
A \cn{GValue} is a class type and not a record type, hence is allocated on the heap. The \cn{GValue} has built-in reference counting such that \fn{Clone} will not make an actual copy, only increment.

% The different \cn{GValue} types inherit from from the base class and override methods that make sense. All inn all, it contains a refcount and the actual value.

\subsection{CompositionDescriptor and CompositionObject}
\label{sub:CompositionDescriptor}
The object class, or composition, which we discussed in Section \ref{sub:Object Classes}, is represented through the \cn{CompositionDescriptor} and \cn{CompositionObject} classes. Since \gap~source code is developed in one layer of abstraction above a regular programming language, we need two classes to support compositions, as we see in Figure \ref{fig:linguistic-metamodeling}. The relationship between the descriptor and the object is normally built into the language as classes and objects, but in a model-driven framework, there must be two explicit constructs.

The \cn{CompositionDescriptor} class describes a composition, and represents an object class. Conceptually, such descriptor is the same as a class in a programming language. As described Section \ref{sub:Object Classes}, a composition descriptor contains a list of data descriptors as well as ... \todo{Trenger hjelp her}. A composition descriptor contains data from the information system delevopment layer.

The \cn{CompositionObject} class represents object instances for object classes. Each object has a reference to its composition descriptor, and in addition, there are other variables that store object state, validation errors, formatting, and more. The data belonging to a composition object is stored in a \cn{CompositionObjectValueCollection} class (Section \ref{sub:CompositionObjectValueCollection}).


\subsection{DataDescriptor}
\label{sub:DataDescriptor}
The \cn{DataDescriptor} class describes an attribute in a composition, which is the object class property we studied in Section \ref{sub:Object Class Properties}. It holds all revelant data about a property, mainly type and representation, but also constraints and formatting rules. Instances of the \cn{DataDescriptor} class exist in the information system development layer.

\subsection{CompositionObjectValueCollection}
\label{sub:CompositionObjectValueCollection}
The \cn{CompositionObjectValueCollection} class holds the data for composition objects, and is equivalent to the data stored in class properties in a regular programming language. Alternatively, this collection class can be thought of as a row in a DBMS. The class contains a list of \cn{GValue}s and a list of \cn{DataDescriptor}s. Values are accessed through querying the \cn{CompositionObjectValueCollection} with a \cn{DataDescriptor}, where the correct value is found using a linear search through the list.

\begin{table}
    \begin{tabularx}{\textwidth}{X | X | X}
        Class Name & Concept & Model-driven development layer \\
        \hline
        \hline
        \cn{GValue} & - & Method engineering layer \\
        \hline
        \cn{CompositionDescriptor} & Object Class & Information system development layer \\
        \hline
        \cn{CompositionObject} & Instance of Object Class & Information system layer \\
        \hline
        \cn{DataDescriptor} & Object Class Property & Information system development layer \\
        \hline
        \cn{CompositionObject- ValueCollection} & Values of Object Class Property & Information system layer
    \end{tabularx}
    \caption{Classes and layers}
    \label{tab:concept-class-mapping}
\end{table}

An overview over classes, and how they relate to \gap~concepts and model-driven engineering layers is found in Table \ref{tab:concept-class-mapping}.

\section{Challenges in Genus App Platform}
\label{sec:Challenges in Genus App Platform}
There is a number of challenges in \gap~the way it is designed today. The main focus of the source code has been to have a readable code that is easy to maintain. In addition, it is challenging to make changes in the core of the platform. In this section, we discuss some of these challenges, which are related to memory usage and memory access.

\subsection{Excessive amount of pointers}
\label{sub:Excessive amount of pointers}
\afigure{img/gap-original-instantiation.png}{Pointers in \gap. For every object, there is not only a list to the values, but also a list to the corresponding data descriptors.}{fig:gap-original-instantiation}{0.8}
One of the main challenges in \gap~is the large amount of pointers needed to store object data. As seen in Figure \ref{fig:gap-original-instantiation}, each \cn{CompositionObjectValueCollection} has a pointer to all data descriptors. Although this implementation is flexible because every value collection is self contained and objects can have a variable number of fields lodaded, the overhead for storing all these pointers is substantial. This is especially true on a 64-bit architecture, where each pointer uses 8 bytes.

We study the pointer overhead by using a simple example. We assume an object class with 15 class properties. In the data source there are 1,000,000 million elements.
\begin{itemize}
    \item \textbf{1 pointer}, for the data source.
    \item \textbf{2 pointers}, for the composition descriptor and the pointer to the list of data descriptors.
    \item \textbf{15 pointers}, for the composition data descriptors
    \item Per object:
    \begin{itemize}
        \item \textbf{1 pointer}, for the composition object.
        \item \textbf{1 pointer}, for the value collection pointer.
        \item \textbf{15 pointers}, for all data descriptors in the value collection.
        \item \textbf{15 pointers}, for all values in the value collection.
    \end{itemize}
\end{itemize}
This results in 32,000,018 pointers, which is roughly 244mb on a 64-bit architecture. Keep in mind that this number only contains storage used for pointers, not the actual data itself. If all values are 32-bit integers, the raw data itself would only take up approximately 57mb, which in this example is only 20\% of the pointers.

\subsection{Ineficcient Data Access and Poor Memory Locality}
\label{sub:Ineficcient Data Access and Poor Memory Locality}
Commonly in \gap, there are operations that perform calculations or evaluates predicates on a large number of values. These operations access many values consecutively, and it is not uncommon they scan all values for a data descriptor in a data source. For instance, if you want to sum all numbers for a data descriptor, the following is done for every object in the data source:

\begin{itemize}
    \item The \cn{CompositionObjectValueCollection} is scanned linearly for the correct data descriptor.
    \item The corresponding \cn{GValue} is found, and the accessor method (i.e. \fn{GetAsInteger}) is looked up in the dispatch table.
    \item A new stack frame is put on the stack to run the \fn{GetAsInteger} method.
\end{itemize}

Although the compiler might be able to optimize some of the steps above, it is far from ideal. For instance, the accessor method for the value is virtual and cannot be inlined. As we saw in Section \ref{sec:Background Information on Modern CPUs and Compilers}, the difference between minimal and maximal CPU utilization can easily be one order of magnitude, where branches may severely hurt performance. Last, the linear search through data descriptors hurts performance.

Not only is the data access pattern complex, we may also assume poor memory locality. As \cn{GValue}s are heap allocated and managed my the memory manager, we have lost control over where they exist on the heap. We must assume the position is arbitrary, and that \cn{GValue}s consecutive in calculation are on different cache lines. As we saw in Chapter \ref{chap:Background}, cache locality is paramount for performance.

\subsection{Inefficient storage usage}
\label{sub:Inefficient storage usage}
\cn{GValue}s have much storage overhead. First, since they are ref counted, each value contains a 4 byte integer. In addition, since a \cn{GValue} is a class type, the first 8 bytes in an object is a pointer to a virtual method table. At last, storing the value also requires a pointer to the value, which is an additional 8 byte. Hence, for a 32-bit integer, only 4 out of 24 bytes are used to store the actual data.

In addition, \cn{GValues} in a \cn{CompositionObjectValueCollection} does not apply compression. Using the same logic as the above paragraph, we see that each boolean value in \gap~takes up 21 bytes. In theory, only 1 bit is needed for such value, and we studied techniques in Chapter \ref{chap:Background} how dictionary encoding and bitpacking can help acheive that.

We saw in the background section that compression and using storage efficiently can turn a process from I/O bound to CPU bound, and is extremely important for optimal performance.

\section{Chapter Conclusion and Thesis Motivation}
\label{sec:Chapter Conclusion and Thesis Motivation}
Now that we have established the relevant use cases for \genus, studied background theory in model-driven engineering and database technology, and analyzied \gap~source code, we may present the thesis motivation.

First of all, we observe that \gap~is in fact a sophisticated in-memory database with data that are persisted to SQL-supporting back-ends. The main difference is that \gap~has extensive knowledge about the data, or metadata, as well as full control over where and for what the data is used for. The platform knows more about the data than a regular database using the data interpretation, which databases are normally agnostic. We therefore conclude that theory from database technology can be applied to model-driven development and \gap, and that there is a large potential in the metadata.

Our second observation is that we have a possibility to implement optimizations from the database technology in the method engineering layer without affecting the information system development layer. Much like a compiler optimizes code better and more reliable \cite{Selic2003-qa}, we see the potential in letting \gap~optimize without programmer or modeller intervention. In this thesis, we focus on the method engineering layer to improve performance for the end-users. We plan to implement our changes such that it affects the information system development layer as little as possible.
