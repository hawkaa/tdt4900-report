\chapter{Genus Application Framework}
\label{chap:Genus Application Framework}
\genusSoftware~is bla bla bla. We separate between three different user types, which also relates to the different language levels explained in Section~\ref{sec:Model-driven Development}.

To achieve our goal, we realized that we had to invent generic software concepts and mechanisms on a higher level of abstraction than any traditional computational terms used by programming languages \cite{noauthor_undated-qy}. These concepts and mechanisms needed to be precise and non-ambiguous, using terms close to the user.
 
We used the concepts and mechanisms as modeling constructs to solve problems specific for our customer’s applications. Step-by-step we refined the concepts and mechanisms to reach the point where we are today – a mature, feature-rich application model technology, running large real life applications for our customers. The application models are composed of our customers' business objects and logic with sufficient detail to let Genus run from the model itself.
 
The term Genus comes from Latin genus “descent, family, type, gender”, and was chosen to underline the fact that in a new world of software application models, the main challenge is the classification and definition of new concepts in an orderly manner.

\begin{itemize}
    \item The end users
    \item \genusSoftware~expert users. Their customers are the end users.
    \item \genusSoftware~developers, the ones who develop the framework itself. Their customers are the expert users.
\end{itemize}

We work on the developer layer and plan to improve the end user performance without affecting the expert users.

\afigure{img/gaf-components.png}{The components in \genusSoftware.}{fig:gaf-components}{0.8}

\section{Graphical User Interface}
\label{sec:Graphical User Interface}

\section{Customer use cases and problems}
\label{sec:Customer use cases and problems}

\section{Original Implementation}
\label{sec:Original Implementation}

The way \genus~has chosen to implement their software is actually an in-memory database that are persisted to database backends supporting SQL. 


